---
title: "som-esm1"
author: "ACS"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
---

# IPCC region example

## helper function to process time series 

And some package and labeling info

```{r}
#TODO harmonize color bars? at least for precip so it has brown for decreases
library(ggplot2)
library(dplyr)
library(tidyr)
library(kohonen)
library(vegan)  # for vegdist function which gives a dissimilarity index

timeseries_dir <- 'python_curation/extracted_timeseries/'

# get ecs ordering/labels
esm_labels <- read.csv(paste0(timeseries_dir,'global_tas_allesms.csv'), stringsAsFactors = FALSE) %>%
  select(esm) %>% distinct %>% 
  mutate(plotesm = paste0(letters[as.integer(row.names(.))], '.', esm),
         ECS_order = as.integer(row.names(.)))

process_time_series <- function(time_series_df, esm_label_info,
                                hist_start = 1995, hist_end = 2014){
  # Get ensemble member values for projection runs:
  # 1. 2080-2099 average
  # 2. loess detrend each ensemble member to get IAV
  #
  # split by run
  non_hist <- time_series_df %>% 
    filter(experiment != 'historical') %>% 
    select(year, ann_agg, esm, experiment, ensemble, variable, region)
  
  grouped <- split(non_hist, f = list(non_hist$esm, 
                                      non_hist$experiment,
                                      non_hist$ensemble, 
                                      non_hist$variable ,
                                      non_hist$region) )
  # split creates group of every possible combo of the variables and fills in
  # empty dataframes for the ones that don't exist in data. Drop those
  grouped <- grouped[lapply(grouped, nrow)>0]
  
  processed_groups <- lapply(grouped, FUN = function(run_df){
    loess_resids <- loess(run_df$ann_agg ~ run_df$year)$residuals
    
    run_df %>%
      filter(year >= 2080, year <= 2099) %>%
      group_by(esm, experiment, ensemble, variable, region) %>%
      summarise(average_2080_2099 = mean(ann_agg)) %>% 
      ungroup  %>%
      mutate(iasd = sd((loess_resids))) ->
      output_df
    
    return(output_df)
    
  })
  
  individual_stats <- do.call(bind_rows, processed_groups)
  rm(non_hist)
  rm(grouped)
  rm(processed_groups)
  
  # calculate ensemble averages
  individual_stats %>%
    group_by(esm, experiment, variable,region) %>%
    summarise(average_2080_2099 = mean(average_2080_2099),
              iasd = mean(iasd)) %>%
    ungroup ->
    ensemble_stats
  
  
  # get ensemble average historical average value:
  time_series_df %>%
    filter(experiment == 'historical',
           year >= hist_start,
           year <= hist_end) %>%
    group_by(esm, experiment, ensemble, variable, region) %>%
    summarise(historical_average = mean(ann_agg)) %>%
    ungroup %>%
    group_by(esm, experiment, variable, region) %>%
    summarise(historical_average = mean(historical_average)) %>%
    ungroup %>%
    select(-experiment) ->
    historical_ens
  
  
  # shape and calculate changes for plotting:
  ensemble_stats %>%
    left_join(historical_ens, by = c('esm', 'variable', 'region')) %>%
    left_join(esm_label_info, by = 'esm') %>%
    mutate(change = average_2080_2099 - historical_average,
           pct_change = 100*(average_2080_2099 - historical_average)/historical_average) ->
    plot_tbl
  
return(plot_tbl)
}
```


## load for an ESM
```{r}
region_timeseries <- read.csv(paste0(timeseries_dir, 'IPCC_land_regions_tas_CESM2-WACCM_timeseries_1980_2099.csv'),
                              stringsAsFactors = FALSE) %>% mutate(region = acronym)

region_tas_summary <- suppressMessages(process_time_series(time_series_df = region_timeseries, esm_label_info = esm_labels))


region_pr_summary <- suppressMessages(process_time_series(time_series_df = 
                                                            read.csv(paste0(timeseries_dir, 'IPCC_land_regions_pr_CESM2-WACCM_timeseries_1980_2099.csv'),
                                                                     stringsAsFactors = FALSE) %>%
                                                            rename(ann_agg=pr) %>% 
                                                            mutate(region = acronym) ,
                                                          esm_label_info = esm_labels))

print(head(region_tas_summary))
print(head(region_pr_summary))
```

## reshape so each row is an observation

observation = esm - experiment - region - tas change-tas iasd - pr pct change

```{r}
region_tas_summary %>% 
  select(esm, experiment, region, iasd, change) %>%
  rename(tas_change = change) %>%
  left_join(region_pr_summary %>% 
              select(esm, experiment, region, pct_change) %>% 
              rename(pr_pct = pct_change),
                     by = c('esm', 'experiment', 'region')) ->
  region_summary

print(head(region_summary))

```

```{r, echo=FALSE}
# cleanup
rm(region_timeseries)
rm(region_tas_summary)
rm(region_pr_summary)
```


## test 1

let's see if it can learn the experiment or region clustering of the data points if I only give the numerical values

```{r}
region_numerical <- as.data.frame(region_summary[c('iasd', "tas_change", "pr_pct")])

#### train the SOM ####
sample.size <- nrow(region_numerical)
print(paste('Num Observations is', sample.size ))

## define a grid for the SOM and train
grid.size <- ceiling(sample.size ^ (1/2.5))
som.grid <- somgrid(xdim = grid.size, ydim = grid.size, topo = 'hexagonal', toroidal = T)
som.model <- som(data.matrix(region_numerical), grid = som.grid)
```


```{r}
## extract some data to make it easier to use

som.events <- som.model$codes[[1]]
print(som.events)

# assign a color to each event because we have 3 metrics
# red = iasd
# green = temperature change
# blue = precip change
som.events.colors <- rgb( scales::rescale(som.events[,1], to =c(0,255)),
                          scales::rescale(som.events[,2], to =c(0,255)) ,
                         scales::rescale(som.events[,3], to =c(0,255)), 
                         maxColorValue = 255)

# calculate a distance matrix
som.dist <- as.matrix(dist(som.events))

```

### plots
```{r}
## generate a plot of the untrained data.  this isn't really the configuration at first iteration, but
## serves as an example
plot(som.model,
     type = 'mapping',
     bg = som.events.colors[sample.int(length(som.events.colors), size = length(som.events.colors))],
     keepMargins = F,
     col = NA,
     main = '')

## generate a plot after training.
plot(som.model,
     type = 'mapping',
     bg = som.events.colors,
     keepMargins = F,
     col = NA,
     main = '')
```
### look for num clusters
```{r}
#### look for a reasonable number of clusters ####

## Evaluate within cluster distances for different values of k.  This is
## more dependent on the number of map units in the SOM than the structure
## of the underlying data, but until we have a better way...

## Define a function to calculate mean distance within each cluster.  This
## is roughly analogous to the within clusters ss approach

clusterMeanDist <- function(clusters){
  cluster.means = c()
  
  for(c in unique(clusters)){
    temp.members <- which(clusters == c)
    
    if(length(temp.members) > 1){
      temp.dist <- som.dist[temp.members,]
      temp.dist <- temp.dist[,temp.members]
      cluster.means <- append(cluster.means, mean(temp.dist))
    }else(cluster.means <- 0)
  }
  
  return(mean(cluster.means))
  
}

try.k <- 2:62
cluster.dist.eval <- as.data.frame(matrix(ncol = 3, nrow = (length(try.k))))
colnames(cluster.dist.eval) <- c('k', 'kmeans', 'hclust')

for(i in 1:length(try.k)) {
  cluster.dist.eval[i, 'k'] <- try.k[i]
  cluster.dist.eval[i, 'kmeans'] <- clusterMeanDist(kmeans(som.events, centers = try.k[i], iter.max = 20)$cluster)
  cluster.dist.eval[i, 'hclust'] <- clusterMeanDist(cutree(hclust(vegdist(som.events)), k = try.k[i]))
}

plot(cluster.dist.eval[, 'kmeans'] ~ try.k,
     type = 'l')

lines(cluster.dist.eval[, 'hclust'] ~ try.k,
      col = 'red')

legend('topright',
       legend = c('k-means', 'hierarchical'),
       col = c('black', 'red'),
       lty = c(1, 1))

```




Try k = 9

```{r}
# Define a function for make a simple plot of clustering output.
## This is the same as previousl plotting, but we define the function
## here as we wanted to play with the color earlier.

plotSOM <- function(clusters){
  plot(som.model,
       type = 'mapping',
       bg = som.events.colors,
       keepMargins = F,
       col = NA)
  
  add.cluster.boundaries(som.model, clusters, color = 'red')
}

cluster.tries <- list()

for(k in c(5, 8, 9, 10)){
   ## k-means clustering
  
  som.cluster.k <- kmeans(som.events, centers = k, iter.max = 100, nstart = 10)$cluster # k-means
  
  ## hierarchical clustering
  
  som.dist <- dist(som.events) # hierarchical, step 1
  som.cluster.h <- cutree(hclust(som.dist), k = k) # hierarchical, step 2

  cluster.tries[[paste0('som.cluster.k.', k)]] <- som.cluster.k
  cluster.tries[[paste0('som.cluster.h.', k)]] <- som.cluster.h
}

print('cluster size = 5')
plotSOM(cluster.tries$som.cluster.k.5)
plotSOM(cluster.tries$som.cluster.h.5)

print('cluster size = 8')
plotSOM(cluster.tries$som.cluster.k.8)
plotSOM(cluster.tries$som.cluster.h.8)

print('cluster size = 9')  
plotSOM(cluster.tries$som.cluster.k.9)
plotSOM(cluster.tries$som.cluster.h.9)

print('cluster size = 10')
plotSOM(cluster.tries$som.cluster.k.10)
plotSOM(cluster.tries$som.cluster.h.10)
```

